<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Taller de Programación I</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Inicio.html"><strong aria-hidden="true">1.</strong> Inicio</a></li><li class="chapter-item expanded "><a href="recursos.html"><strong aria-hidden="true">2.</strong> Bibliografía y Recursos</a></li><li class="chapter-item expanded "><a href="clases.html"><strong aria-hidden="true">3.</strong> Clases</a></li><li class="chapter-item expanded "><a href="guias.html"><strong aria-hidden="true">4.</strong> Guías</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guia_1.html"><strong aria-hidden="true">4.1.</strong> Guía 1</a></li><li class="chapter-item expanded "><a href="guia_2.html"><strong aria-hidden="true">4.2.</strong> Guía 2</a></li><li class="chapter-item expanded "><a href="guia_3.html"><strong aria-hidden="true">4.3.</strong> Guía 3</a></li></ol></li><li class="chapter-item expanded "><a href="proyecto.html"><strong aria-hidden="true">5.</strong> Proyecto</a></li><li class="chapter-item expanded "><a href="rust_arg.html"><strong aria-hidden="true">6.</strong> Grupo Rust Argentina</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Taller de Programación I</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="inicio"><a class="header" href="#inicio">Inicio</a></h1>
<p>Bienvenidos y bienvenidas a la catedra de Taller de Programación I de <a href="http://www.fi.uba.ar/">FIUBA</a>.</p>
<p>Los docentes de la Cátedra son:</p>
<ul>
<li>
<p><strong>Profesor:</strong> Ing. Pablo A. Deymonnaz</p>
</li>
<li>
<p><strong>Ayudantes:</strong></p>
<ul>
<li>Juan Bono</li>
<li>Iñaki Garay</li>
<li>Uriel Kelman</li>
<li>Matías Lafroce</li>
</ul>
</li>
</ul>
<p>Las clases serán los días lunes de 18 a 22 hs.</p>
<h2 id="materias-correlativas"><a class="header" href="#materias-correlativas">Materias Correlativas</a></h2>
<p>Las materias correlativas vigentes necesarias para poder cursar la materia dependen de la Carrera y Plan que esté cursando el estudiante:</p>
<ul>
<li>
<p><strong>Ingeniería en Informática:</strong></p>
<ul>
<li>Estructura del Computador (66.70)</li>
<li>Algoritmos y Programación II (75.41)</li>
<li>Análisis Numérico (75.12)</li>
</ul>
</li>
<li>
<p><strong>Licenciatura en Análisis de Sistemas (1986):</strong></p>
<ul>
<li>Organización del Computador (75.03)</li>
<li>Algoritmos y Programación II (75.41)</li>
</ul>
</li>
<li>
<p><strong>Licenciatura en Análisis de Sistemas (2014):</strong></p>
<ul>
<li>Organización del Computador (95.57)</li>
<li>Algoritmos y Programación III (95.02)</li>
</ul>
</li>
<li>
<p><strong>Ingeniería en Electrónica (2009):</strong></p>
<ul>
<li>Algoritmos y Programación II (95.12)</li>
</ul>
</li>
</ul>
<h2 id="desarrollo-del-proyecto"><a class="header" href="#desarrollo-del-proyecto">Desarrollo del Proyecto</a></h2>
<p>En la materia vamos a trabajar con el lenguaje de programación <a href="https://www.rust-lang.org/">Rust</a>.</p>
<p>Desarrollaremos un Proyecto a partir de la sexta semana de clases, en grupos de 3 personas.
Cada grupo tendrá el seguimiento del avance del trabajo semanalmente con un docente de la cátedra.</p>
<h1 id="bibliografía"><a class="header" href="#bibliografía">Bibliografía</a></h1>
<p>La bibliografía recomendad de la materia para el aprnedizaje del lenguaje Rust es:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>, Steve Klabnik y Carol Nichols. Es el libro oficial del lenguaje, y es la referencia principal para aprender el lenguaje.</li>
<li><a href="https://www.oreilly.com/library/view/programming-rust/9781491927274/">Programming Rust</a>, Jim Blandy, Jason Orendorff.O'Reilly Media, Inc. Es un libro muy bueno que explica los conceptos del lenguaje de forma exhaustiva con profundidad.</li>
<li><a href="https://livebook.manning.com/book/rust-in-action/welcome/v-16/">Rust in Action</a>, Tim McNamara</li>
</ul>
<h2 id="otros-recursos-de-interés"><a class="header" href="#otros-recursos-de-interés">Otros recursos de interés</a></h2>
<p>Otros recursos para consultar:</p>
<ul>
<li><a href="https://goyox86.github.io/elpr/">El Lenguaje de Programación Rust</a>. Una guía de referencia en español.</li>
<li><a href="https://cheats.rs/">Rust Language Cheat Sheet</a>. Un resumen de los elementos del lenguaje, para tener a mano.</li>
</ul>
<h2 id="artículos-de-blogs"><a class="header" href="#artículos-de-blogs">Artículos de blogs</a></h2>
<ul>
<li><a href="https://www.possiblerust.com/guide/how-to-read-rust-functions-part-1">How to Read Rust Functions, Part 1</a></li>
</ul>
<h1 id="clases"><a class="header" href="#clases">Clases</a></h1>
<ul>
<li><strong>Clase 1</strong> - Introducción a Rust. <a href="./clases/1-introduccion.pdf">Slides</a> - <a href="./clases/clase-01.tar.bz2">ejemplos de código</a></li>
<li><strong>Clase 2</strong> - Ownership, Lifetimes, Traits, Generics. <a href="./clases/2-ownership.pdf">Slides</a></li>
<li><strong>Clase 3</strong> - Concurrencia / Procesos y Threads / Channels y Locks en Rust. <a href="./clases/3-concurrencia.pdf">Slides</a> - <a href="./clases/clase-03.tar.bz2">ejemplos de código</a></li>
<li><strong>Clase 4</strong> - Introducción a Redes / Sockets en Rust. <a href="./clases/4-sockets.pdf">Slides</a> - <a href="./clases/clase-04.tar.bz2">ejemplos de código</a>
<ul>
<li><a href="./clases/git.pdf">Flujos de desarrollo en GIT</a></li>
</ul>
</li>
</ul>
<h1 id="guías"><a class="header" href="#guías">Guías</a></h1>
<ul>
<li>Ejercicios para practicar la sintaxis del lenguaje: <a href="https://github.com/rust-lang/rustlings">rustlings</a></li>
<li><a href="./guias/guia1-introduccion.pdf">Guía 1</a>: Introducción a Rust</li>
<li><a href="./guias/guia2-ownership.pdf">Guía 2</a>: Ownership</li>
<li><a href="./guias/guia3-concurrencia.pdf">Guía 3</a>: Concurrencia</li>
<li><a href="./guias/guia4-sockets.pdf">Guía 4</a>: Sockets</li>
</ul>
<h1 id="guía-de-ejercicios-1-introducción-a-rust"><a class="header" href="#guía-de-ejercicios-1-introducción-a-rust">Guía de Ejercicios 1: Introducción a Rust</a></h1>
<h2 id="ejercicio-1---ahorcado"><a class="header" href="#ejercicio-1---ahorcado">Ejercicio 1 - Ahorcado</a></h2>
<p>El objetivo del ejercicio es implementar un programa de consola para jugar al <strong>ahorcado</strong>.</p>
<pre><code>Bienvenido al ahorcado de FIUBA!

La palabra hasta el momento es: _ _ _ _ _ _
Adivinaste las siguientes letras: 
Te quedan 5 intentos.
Ingresa una letra: r

La palabra hasta el momento es: _ _ _ _ _ r
Adivinaste las siguientes letras: r
Te quedan 5 intentos.
Ingresa una letra: c
</code></pre>
<p>Si se ingresa una letra que no forma parte de la palabra, se pierde un intento.</p>
<p>La lista de palabras se debe leer de un archivo de texto, donde cada línea del archivo contendrá una palabra.
De esa lista, se deberá elegir una palabra (puede ser una selección secuencial de palabras).</p>
<p>El programa termina cuando se adivina correctamente la palabra pensada, o cuando se acabaron los intentos.</p>
<p>Tips:</p>
<ul>
<li>Recuerda que las variables son inmutables por default. Para cambiar el estado de una variable, se la debe declarar como <strong>mut</strong>.</li>
<li>Se puede comparar Strings usando: <strong>==</strong></li>
<li>Usa <strong>println!(...)</strong> para imprimir elementos en la salida estándar. Para imprimir una variable, puedes escribir algo como esto:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Contenido: {}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Para leer de la entrada estándar, se puede usar algo como esto:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io::stdin()
	.read_line(&amp;mut v)
	.expect(&quot;Error leyendo la linea.&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="parte-b"><a class="header" href="#parte-b">Parte B</a></h3>
<p>Mostrar las letras que se ingresaron y que no forman parte de la palabra (las que hacen que se pierda un intento).</p>
<p>Verificar si se ingresó nuevamente una letra que ya estaba.</p>
<h3 id="parte-c"><a class="header" href="#parte-c">Parte C</a></h3>
<p>Sobre la implementación de las funciones, modelizar una estructura de datos que represente al tipo de error de retorno. Por ejemplo: se agotaron los intentos. Basarse en el <strong>enum Result</strong>.</p>
<h2 id="ejercicio-2---contar-palabras"><a class="header" href="#ejercicio-2---contar-palabras">Ejercicio 2 - Contar palabras</a></h2>
<p>Escribir un programa para contar las frecuencias de palabras únicas leídas de un archivo de entrada.
Luego imprimirlas con sus frecuencias, ordenadas primero por las más frecuentes. Por ejemplo, dado este archivo de entrada: </p>
<pre><code>La casa tiene una ventana
La ventana fue defenestrada
</code></pre>
<p>El programa debe imprimir:</p>
<pre><code>ventana -&gt; 2
La -&gt; 2
casa -&gt; 1
tiene -&gt; 1
una -&gt; 1
fue -&gt; 1
defenestrada -&gt; 1
</code></pre>
<p>Una solución básica consiste en leer el archivo línea por línea, convertirlo a minúsculas, dividir cada línea en palabras y contar las frecuencias en un <strong>HashMap</strong>. Una vez hecho esto, convertir el <strong>HashMap</strong> en una lista de pares de palabras y cantidad y ordenarlas por cantidad (el más grande primero) y por último imprimirlos.</p>
<p>Se debe seguir las siguientes recomendaciones:</p>
<ul>
<li>Para separar en palabras, se debe considerar los espacios en blanco, ignorando los signos de puntuación.</li>
<li>Si la frecuencia de dos palabras es la misma, no importa el orden en el que aparecen las dos palabras en la salida impresa.</li>
<li>No leer el archivo completo en memoria, se puede ir procesando línea por línea, o en conjuntos de líneas. Sí se puede mantener en memoria el hashmap completo.</li>
<li>Usar solamente las herramientas de la biblioteca std del lenguaje.</li>
</ul>
<p>Para leer un archivo línea por línea, se puede utilizar el método
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html#method.read_line">read_line</a>.</p>
<h2 id="ejercicio-3---buscador-full-text"><a class="header" href="#ejercicio-3---buscador-full-text">Ejercicio 3 - Buscador Full-text</a></h2>
<p>La búsqueda de texto está en todos lados. Desde encontrar un mensaje en redes sociales, productos en portales de comercio electrónico, o cualquier otra cosa en la web a través de Google.</p>
<p>En este ejercicio, construiremos un motor de búsqueda sencillo que pueda buscar en millones de documentos y clasificarlos según su relevancia.</p>
<p>El primer paso consiste en la <strong>preparación de los datos</strong>. Necesitamos construir el conjunto de datos sobre el que realizaremos las búsquedas, denominado <strong>corpus</strong>. Este conjunto será un grupo de archivos de texto plano (txt) que puede generarse a partir de artículos de Internet. Cada archivo será un <strong>documento</strong> que estará identificado por un <strong>id</strong>.</p>
<p>Luego se debe realizar la <strong>indexación:</strong> Se debe implementar una estructura conocida como de <strong>índice invertido</strong>. Que será una estructura de datos de tipo <strong>HashMap</strong> que contendrá como clave cada una de las palabras y como valor, el o los ids de documentos en los que aparece la palabra. Para este paso, se debe realizar el proceso de <strong>tokenización</strong>, es decir, obtener cada una de los tokens que conforman al documento, considerando las separaciones de los mismos por espacios en blanco o saltos de línea, y quitando los signos de puntuación. De estos tokens, se debe ignorar las palabras más usadas del lenguaje español (conocidas como <strong>stop words</strong>), por ejemplo, los artículos: la, el, las, los.
Se debe considerar la frecuencia de cada token, es decir, la cantidad de veces que el mismo aparece en el documento. Ese valor debe ser almacenado para el ordenamiento de los resultados.</p>
<p>El último paso es implementar la <strong>búsqueda</strong>. Para ello, se debe solicitar al usuario una frase a buscar y aplicar la tokenización de la misma y la eliminación de las stop words. Se debe buscar los documentos que contengan los términos de búsqueda ingresados.</p>
<p>Luego se debe determinar la relevancia de cada documento resultado de la búsqueda. Para esto, se debe determinar el <strong>puntaje</strong> del documento. Esto se puede computar a partir de sumar las frecuencias de cada uno de los términos encontrados.</p>
<p>Para mejorar el cálculo de puntaje del documento, calcularemos la frecuencia inversa de documentos para un término (denominado <strong>tf-idf</strong>) dividiendo la cantidad de documentos (N) en el índice por la cantidad de documentos que contienen el término, y tomaremos el logaritmo. </p>
<div style="text-align:center"><img src="formulatf.png" /></div>
<p>donde:</p>
<ul>
<li><strong>|D|</strong> es la cantidad de documentos del corpus.</li>
<li><strong>|d ∈ D : t ∈ d|</strong> es el número de documentos donde aparece el término <strong>t</strong>. Si el término no está en la colección se producirá una división-por-cero. Por lo tanto, se suele ajustar esta fórmula a <strong>1 + |d ∈ D : t ∈ d|</strong></li>
</ul>
<p>Luego, multiplicaremos la frecuencia del término con la frecuencia inversa del documento durante nuestra clasificación, por lo que las coincidencias en términos que son raros en el corpus contribuirán más a la puntuación de relevancia.</p>
<h1 id="requerimientos-no-funcionales"><a class="header" href="#requerimientos-no-funcionales">Requerimientos no funcionales</a></h1>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>No se permite utilizar <strong>crates</strong> externos. El único crate autorizado a ser utilizado es <a href="https://crates.io/crates/rand">rand</a> en caso de que se quiera generar valores aleatorios.</li>
<li>El código fuente debe compilarse en la versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Las funciones no deben tener una extensión mayor a 30 líneas. Si se requiriera una extensión mayor, se deberá particionarla en varias funciones.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h1 id="guía-de-ejercicios-2-ownership-en-rust"><a class="header" href="#guía-de-ejercicios-2-ownership-en-rust">Guía de Ejercicios 2: Ownership en Rust</a></h1>
<h2 id="ejercicio-1"><a class="header" href="#ejercicio-1">Ejercicio 1</a></h2>
<p>Analizar las siguientes porciones de código y responder si el mismo compila o no.
Explicar por qué sí o por qué no.</p>
<p>Si no se compila, ¿qué podrías cambiar para que compile? </p>
<pre><pre class="playground"><code class="language-rust">fn main() {
	let mut s = String::from(&quot;hola&quot;);
	let ref1 = &amp;s;
	let ref2 = &amp;ref1;
	let ref3 = &amp;ref2;
	s = String::from(&quot;chau&quot;);
	println!(&quot;{}&quot;, ref3.to_uppercase());
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn drip_drop() -&gt; &amp;String {
    let s = String::from(&quot;hello world!&quot;);
    return &amp;s;
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
	let s1 = String::from(&quot;hola&quot;);
	let mut v = Vec::new();
	v.push(s1);
	let s2: String = v[0];
	println!(&quot;{}&quot;, s2);
}
</code></pre></pre>
<h2 id="ejercicio-2---diff"><a class="header" href="#ejercicio-2---diff">Ejercicio 2 - diff</a></h2>
<p>Encontrar la diferencia entre dos archivos es un problema que es bastante conocido y estudiado.</p>
<p>La mayoría de las implementaciones usan el algoritmo de Myers, en este ejercicio, haremos que calcule la subsecuencia común más larga entre los dos archivos con el algoritmo LCS y use esa información para calcular su diferencia.</p>
<p>Este ejercicio se divide en hitos a cumplir.</p>
<h3 id="leer-los-dos-archivos-en-dos-vectores-de-líneas"><a class="header" href="#leer-los-dos-archivos-en-dos-vectores-de-líneas">Leer los dos archivos en dos vectores de líneas</a></h3>
<p>En este hito, se debe implementar la función <strong>read_file_lines</strong>
la cual debe tomar como parámetro la ruta al archivo y devolver un vector
conteniendo las líneas del archivo.</p>
<h3 id="implementar-el-algoritmo-lcs---longest-common-subsequence"><a class="header" href="#implementar-el-algoritmo-lcs---longest-common-subsequence">Implementar el algoritmo LCS - Longest Common Subsequence</a></h3>
<p><strong>Longest Common Subsequence</strong> es un algoritmo conocido:
dadas dos secuencias, ¿cuál es la subsecuencia más larga que aparece en ambas?</p>
<p>Si las secuencias de caracteres son <strong>a b c d</strong> y <strong>a d b c</strong>, la subsecuencia
común más larga es <strong>a b c</strong>, porque estos caracteres aparecen en ambas secuencias en
ese orden (notar que la subsecuencia no necesita ser consecutiva, sino que debe estar
en orden).</p>
<p>Cuando se hace el diff entre dos archivos, queremos determinar cuáles línas deben ser
agregadas o eliminadas entre ellos.
Para lograr esto, necesitamos identificar las línas que son comunes entre ambos archivos.
Esto se enmarca en lo que se conoce como un problema LCS -hay un buen <a href="https://www.youtube.com/watch?v=NnD96abizww">video explicativo</a>-: tenemos las dos secuencias de líneas
y queremos encontrar la mayor subsecuencia de línas que aparecen en ambos archivos;
estas líneas son la que no fueron modificadas y las otras líneas son las que fueron agregadas 
o eliminadas.</p>
<p>La solución incluye completar una grilla con los largos de subsecuencias.
El siguiente es un fragmento de pseudocódigo que se puede usar como base para reimplementar
en Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let X and Y be sequences
let m be the length of X, and let n be the length of Y

C = grid(m+1, n+1)
// recordar que .., es inclusivo para el límite inferior, pero excluye al superior
for i := 0..m+1
    C[i,0] = 0
for j := 0..n+1
    C[0,j] = 0
for i := 0..m
    for j := 0..n
        if X[i] = Y[j]
            C[i+1,j+1] := C[i,j] + 1
        else
            C[i+1,j+1] := max(C[i+1,j], C[i,j+1])

return C
<span class="boring">}
</span></code></pre></pre>
<h3 id="usar-el-lcs-para-construir-el-diff"><a class="header" href="#usar-el-lcs-para-construir-el-diff">Usar el LCS para construir el diff</a></h3>
<p>Implementar e invocar al siguiente pseudocódigo para imprimir el diff:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// C es la grilla computada por lcs()
// X e Y son las secuencias
// i y j especifican la ubicacion dentro de C que se quiere buscar cuando 
//    se lee el diff. Al llamar a estar funcion inicialmente, pasarle
//    i=len(X) y j=len(Y)
function print_diff(C, X, Y, i, j)
	if i &gt; 0 and j &gt; 0 and X[i-1] = Y[j-1]
		print_diff(C, X, Y, i-1, j-1)
		print &quot;  &quot; + X[i-1]
	else if j &gt; 0 and (i = 0 or C[i,j-1] &gt;= C[i-1,j])
		print_diff(C, X, Y, i, j-1)
		print &quot;&gt; &quot; + Y[j-1]
	else if i &gt; 0 and (j = 0 or C[i,j-1] &lt; C[i-1,j])
		print_diff(C, X, Y, i-1, j)
		print &quot;&lt; &quot; + X[i-1]
	else
		print &quot;&quot;
<span class="boring">}
</span></code></pre></pre>
<h1 id="requerimientos-no-funcionales-1"><a class="header" href="#requerimientos-no-funcionales-1">Requerimientos no funcionales</a></h1>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>No se permite utilizar <strong>crates</strong> externos. El único crate autorizado a ser utilizado es <a href="https://crates.io/crates/rand">rand</a> en caso de que se quiera generar valores aleatorios.</li>
<li>El código fuente debe compilarse en la versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Las funciones no deben tener una extensión mayor a 30 líneas. Si se requiriera una extensión mayor, se deberá particionarla en varias funciones.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h1 id="guía-de-ejercicios-3-concurrencia-en-rust"><a class="header" href="#guía-de-ejercicios-3-concurrencia-en-rust">Guía de Ejercicios 3: Concurrencia en Rust</a></h1>
<h2 id="ejercicio-1---cuentas-bancarias"><a class="header" href="#ejercicio-1---cuentas-bancarias">Ejercicio 1 - Cuentas bancarias</a></h2>
<p>El fragmento de código 1 hace uso de <strong>unsafe</strong> para poder mutar una variable global.
Esto introduce condiciones de carrera sobre los datos (<strong>data races</strong>) que provocan que el programa 
falle de manera imprevista al correrlo repetidas veces.
Es decir, el problema se presenta en alguno de los posibles escenarios de ejecución.</p>
<p>Corregir el programa haciendo uso de las abstracciones que provee Rust para el manejo
de la concurrencia de manera que no se produzcan errores.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

struct Account(i32);

impl Account {
	fn deposit(&amp;mut self, amount: i32) {
		println!(&quot;op: deposit {}, available funds: {:?}&quot;, amount, self.0);
		self.0 += amount;
	}
	
	fn withdraw(&amp;mut self, amount: i32) {
		println!(&quot;op: withdraw {}, available funds: {}&quot;, amount, self.0);
		if self.0 &gt;= amount {
			self.0 -= amount;
		} else {
			panic!(&quot;Error: Insufficient funds.&quot;)
		}
	}
	
	fn balance(&amp;self) -&gt; i32 {
		self.0
	}
}

static mut ACCOUNT: Account = Account(0);

fn main() {
	let customer1_handle = thread::spawn(move || unsafe {
		ACCOUNT.deposit(40);
	});
	
	let customer2_handle = thread::spawn(move || unsafe {
		ACCOUNT.withdraw(30);
	});
	
	let customer3_handle = thread::spawn(move || unsafe {
		ACCOUNT.deposit(60);
	});
	
	let customer4_handle = thread::spawn(move || unsafe {
		ACCOUNT.withdraw(70);
	});
	
	let handles = vec![
	customer1_handle,
	customer2_handle,
	customer3_handle,
	customer4_handle,
	];
	
	for handle in handles {
		handle.join().unwrap();
	}
	
	let savings = unsafe { ACCOUNT.balance() };
	
	println!(&quot;Balance: {:?}&quot;, savings);
}
</code></pre></pre>
<h2 id="ejercicio-2---threadpool"><a class="header" href="#ejercicio-2---threadpool">Ejercicio 2 - ThreadPool</a></h2>
<p>Un <strong>threadpool</strong> mantiene varios hilos de ejecución (<strong>threads</strong>) en espera de que el programa supervisor asigne tareas para su ejecución simultánea. Al mantener un grupo de threads, el modelo aumenta el rendimiento y evita la latencia en la ejecución debido a la frecuente creación y destrucción de threads para tareas de corta duración. </p>
<p>En este ejercicio se debe armar un <strong>threadpool</strong> sencillo haciendo uso de
las herramientas para computación concurrente que nos provee la biblioteca
estándar de Rust.</p>
<p>Para distribuir las tareas a realizar entre los threads del pool se puede
utilizar una cola concurrente.</p>
<p>Consideraciones a tener en cuenta:</p>
<ul>
<li>La estructura de datos utilizada para distribuir el trabajo.</li>
<li>¿Que se hace cuando una tarea enviada al threadpool provoca que un thread muera? Esta situación no debería afectar a otros threads. Ademas tras la muerte de un thread, se debe crear otro de forma de que la cantidad
total de threads en el pool no cambie.</li>
<li>Cuando la threadpool es terminada o sale de scope todos los threads deberian finalizar.</li>
</ul>
<p>El fragmento de código 2 muestra un ejemplo de uso:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
	let pool = ThreadPool::new(4);
	for i in 0..4 {
		pool.spawn(move || {
			std::thread::sleep(std::time::Duration::from_millis(250 * i));
			println!(&quot;This is Task {}&quot;, i);
		});
	}
	std::thread::sleep(std::time::Duration::from_secs(2));
}
</code></pre></pre>
<h2 id="ejercicio-3---contar-palabras-concurrente"><a class="header" href="#ejercicio-3---contar-palabras-concurrente">Ejercicio 3 - Contar palabras concurrente</a></h2>
<p>Escribir un programa, basado en el ejercicio 2 de la guía 1, para contar las frecuencias de palabras únicas leídas desde varios archivos de entrada.</p>
<p>La lectura y procesamiento de los archivos debe ser realizada de forma concurrente. Una vez finalizado el procesamiento de los mismos, imprimirlos con sus frecuencias, ordenados primero por las  más frecuentes.</p>
<p>Realizar las siguientes implementaciones y comparar los tiempos de ejecución:</p>
<ul>
<li>Un mapa de resultados parciales por thread (por archivo), unir las sumas parciales al hacer <strong>join()</strong>, utilizando el valor de retorno de los hilos.</li>
<li>Un mapa de resultados parciales por thread, enviar las sumas parciales de los threads utilizando channels.</li>
<li>Un mapa de resultados globales accedidos por thread.</li>
</ul>
<h1 id="requerimientos-no-funcionales-2"><a class="header" href="#requerimientos-no-funcionales-2">Requerimientos no funcionales</a></h1>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>No se permite utilizar <strong>crates</strong> externos. El único crate autorizado a ser utilizado es <a href="https://crates.io/crates/rand">rand</a> en caso de que se quiera generar valores aleatorios.</li>
<li>El código fuente debe compilarse en la versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Las funciones no deben tener una extensión mayor a 30 líneas. Si se requiriera una extensión mayor, se deberá particionarla en varias funciones.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h1 id="proyecto"><a class="header" href="#proyecto">Proyecto</a></h1>
<p>Será publicado próximamente.</p>
<h1 id="grupo-rust-argentina"><a class="header" href="#grupo-rust-argentina">Grupo Rust Argentina</a></h1>
<p>Invitamos a los alumnos de la materia y a toda la comunidad de la FIUBA a participar del grupo Rust Argentina.</p>
<ul>
<li><a href="https://rust-lang-ar.github.io/">Sitio web</a></li>
<li><a href="https://www.meetup.com/es/Rust-Argentina/">Meetup</a></li>
<li><a href="https://t.me/rust_lang_ar">Grupo de Telegram</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
